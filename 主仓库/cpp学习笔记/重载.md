为什么在操作符重载和拷贝构造函数中传入的是const ClassName& var?
---
- const
	- 安全考虑:防止被不小心修改
	- 例外: 为什么输入操作符要用非const引用参数 (需要修改对象)
- &使用值传递
	- **提高性能** - 避免不必要的对象拷贝
	- ==**避免无限递归**（特别是拷贝构造函数）== 
	-  **支持链式操作** - 通过返回引用支持 `a = b = c`
	- **支持常量对象** - const引用可以绑定到常量对象
	- **支持临时对象** - const引用可以绑定到右值
	- **表达正确的语义** - 明确参数是输入、输出还是输入输出

一元运算符重载问题
===
```cpp
class Complex {
private:
    double i;
    double j;
public:    
    Complex operator ++();//前缀自增
    Complex operator ++(int);//后缀自增，参数需要加int
};
Complex Complex::operator ++() {
    ++i;
    ++j;
    return *this;
}

Complex Complex::operator ++(int) {
    Complex temp =*this;
    ++*this;
    return temp;
}

```
其中,无参数的重载是前缀自增,有参数的是后缀自增
- 前缀自增是先增后用,后缀自增是先用后增,因此需要保存*原始值*
- 后缀自增的参数int叫作**哑元参数**
```cpp
class Example {
public:
    // 编译器如何区分这两个函数？
    Example& operator++();    // 前缀
    Example operator++(int);  // 后缀
    
    // int参数的作用：
    // 1. 语法上区分前缀和后缀版本
    // 2. 不需要实际使用这个参数
    // 3. 只是一个占位符，表明这是后缀版本
};

void testDummyParameter() {
    Example obj;
    
    ++obj;    // 调用 operator++() - 前缀
    obj++;    // 调用 operator++(int) - 后缀
    
    // 实际上，编译器将 obj++ 转换为：
    // obj.operator++(0);
    // 这个0就是传递给哑元参数的值
}
```
1. **语法区分**：
    
    - 前缀：`operator++()`
        
    - 后缀：`operator++(int)`（哑元参数）
        
2. **返回值不同**：
    
    - 前缀：返回自增后的对象**引用**（支持链式操作）
        
    - 后缀：返回自增前的对象**副本**（额外的临时对象）
        
3. **性能差异**：
    
    - 前缀：更高效，没有临时对象
        
    - 后缀：有额外开销，需要创建和返回临时对象


输入输出运算符重载
---
和其他的不同,只能使用友元函数定义
```cpp
class Distance
{
   private:
      int feet;             // 0 到无穷
      int inches;           // 0 到 12
   public:
      // 所需的构造函数
      Distance(){
         feet = 0;
         inches = 0;
      }
      Distance(int f, int i){
         feet = f;
         inches = i;
      }
      friend ostream &operator<<( ostream &output, 
                                       const Distance &D )
      { 
         output << "F : " << D.feet << " I : " << D.inches;
         return output;            
      }
 
      friend istream &operator>>( istream  &input, Distance &D )
      { 
         input >> D.feet >> D.inches;
         return input;            
      }
};
```

如果用成员函数定义要使用 d1<<cout ; 调用
```cpp
#include <iostream>
using namespace std;
 
class Distance
{
    private:
        int feet;             // 0 到无穷
        int inches;           // 0 到 12
    public:
        // 所需的构造函数
        Distance(){
            feet = 0;
            inches = 0;
        }
        Distance(int f, int i){
            feet = f;
            inches = i;
        }
        ostream& operator<<( ostream & os)
        {
        os<<"英寸："<<feet<<"\n英尺："<<inches;
        return os;
    }
};
int main ()
{
    Distance d1(20,18);
    d1<<cout;//相当于d1.operator<<(cout)
}
```

流操作符重载时使用引用的原因如下：

1. **效率**：避免不必要的拷贝。流对象（如`ostream`和`istream`）通常比较大，拷贝它们的开销很大，而且可能不允许拷贝（例如，`ostream`和`istream`的拷贝构造函数是私有的）。使用引用可以避免拷贝，提高效率。
    
2. **修改流状态**：在`istream& operator>>`中，我们需要修改流对象，因为提取操作会改变流的状态（例如，移动读取位置，设置错误标志等）。如果使用值传递，则修改的是流对象的副本，不会影响原始流。使用引用（特别是非常量引用）允许函数修改传入的流对象。
    
3. **链式调用**：流操作符通常支持链式调用，例如`cin >> a >> b`或`cout << a << b`。这要求操作符返回流的引用，这样每次操作后返回的是同一个流对象，才能继续进行操作。

复合赋值操作符
---
重写复合赋值操作符的时候，一定要记得，要把运算结果赋给左值，再返回左值。如果直接返回结果，我们将不会被调用处看到左值被运算的效果。
错误
```cpp
class A {
public:
    int value;
    
    A(int v = 0) : value(v) {}
    
    // 错误的 += 重载：直接返回结果，不修改左值
    A operator+=(const A& other) {
        A result(value + other.value);  // 创建临时结果
        return result;                  // 错误：没有修改当前对象！
    }
    
    // 为了方便测试，重载 <<
    friend ostream& operator<<(ostream& os, const A& obj) {
        os << obj.value;
        return os;
    }
};
```
正确
```cpp
#include <iostream>
using namespace std;

class A {
public:
    int value;
    
    A(int v = 0) : value(v) {}
    
    // 正确的 += 重载：修改左值并返回引用
    A& operator+=(const A& other) {
        value += other.value;    // 1. 修改当前对象
        return *this;           // 2. 返回当前对象的引用
    }
    
    // 为了方便测试，重载 <<
    friend ostream& operator<<(ostream& os, const A& obj) {
        os << obj.value;
        return os;
    }
};
```