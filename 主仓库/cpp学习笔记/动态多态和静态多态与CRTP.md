## 动态多态
----
使用虚函数实现,基类把子类的共同功能声明为多个虚函数接口,各个子类重写这些虚函数. 
代码可以通过指向基类的引用或指针来操作这些对象

由于使用了虚函数,动态多态是在运行时完成的,带来的优点是可以处理异质对象集合,缺点是需要在调用虚函数时查虚表(vtable),造成性能损失

## 静态多态
---
使用模板实现 , 对于相关的各个对象类型,直接实现其定义,不需要共有基类,甚至不需要有关系,只需要满足各个具体类的实现中要求相同的接口声明,(这里的接口被成为隐式接口)

注意

```cpp
```text
template<typename Widget,typename Other>
void DoSomething(Widget& w, const Other& someNasty)
{
    if( w.size() > 0 && w != someNasty) //someNastyT可能是是T类型的某一实例，也可能不是
    {
        Widget temp(w);
        temp.normalize();
        temp.swap(w);
    }
}
```

这看似要求：类型T需要支持size、normalize、swap函数，copy构造函数，可以进行不等比较

类型T是在编译期模板进行具现化时才表现出调用不同的函数，此时对接口的调用就表现出了编译期时多态。

但是，size函数并不需要返回一个整型值以和10比较，甚至都不需要返回一个数值类型，唯一的约束是它返回一个类型为X的对象，且X对象和int类型（数值10的类型）可以调用一个operator >，这个operator>也不一定非要一个X类型的参数不可，它可以通过隐式转换能将X类型转为Y类型对象，而只需要Y类型可以和int类型比较即可(好绕口，请看，这也侧面印证了模板编程编译错误很难解决)。

即: <font color = yellow>具体类的函数返回的类型无须严格与运算的其他类型相同,只需保证双方在经过隐式转换后可以满足运算符的类型要求即可</font>

同样类型T并不需要支持operator!=，而只需要T可以转为X类型对象，someNastyT可以转为Y类型对象，而X和Y可以进行不等比较即可。


静态多态

优点：

由于静多态是在编译期完成的，因此效率较高，编译器也可以进行优化；

有很强的适配性和松耦合性，比如可以通过偏特化、全特化来处理特殊类型；

最重要一点是静态多态通过模板编程为C++带来了泛型设计的概念，比如强大的STL库。

缺点：

由于是模板来实现静态多态，因此模板的不足也就是静多态的劣势，比如调试困难、编译耗时、代码膨胀、编译器支持的兼容性，不能够处理异质对象集合。

动态多态

优点：

OO设计，对是客观世界的直觉认识；

实现与接口分离，可复用；

处理同一继承体系下异质对象集合的强大威力；

缺点：

运行期绑定，导致一定程度的运行时开销；

编译器无法对虚函数进行优化；

笨重的类继承体系，对接口的修改影响整个类层次；

不同点：

本质不同，静态多态在编译期决定，由模板具现完成，而动态多态在运行期决定，由继承、虚函数实现；

动态多态中接口是显式的，以函数签名为中心，多态通过虚函数在运行期实现，静态多台中接口是隐式的，以有效表达式为中心，多态通过模板具现在编译期完成。

相同点：

都能够实现多态性，静态多态/编译期多态、动态多态/运行期多态；

都能够使接口和实现相分离，一个是模板定义接口，类型参数定义实现，一个是基类虚函数定义接口，继承类负责实现；

## CRTP
----
```cpp
template <typename Der>
class Base {
public:
    void interface() {
        // Base 知道它操作的是 Derived 类型
        static_cast<Der*>(this)->implementation();
    }
};

class Derived : public Base<Derived> {  // 这里 Derived 把自己作为模板参数
public:
    void implementation() {
        std::cout << "Derived::implementation()" << std::endl;
    }
};
```
1. **静态多态**：在编译时确定调用，没有虚函数开销
2. **代码复用**：Base 可以提供通用接口，派生类提供具体实现
3. **类型安全**：编译时检查，比 void* 转换更安全
