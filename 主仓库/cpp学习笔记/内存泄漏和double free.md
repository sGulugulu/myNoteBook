#class #易犯严重错误 

首先,定义:
	**内存泄漏（Memory Leak）**是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
	**浅拷贝**:只复制指针,即造成两个指针指向同一地址,而另一地址失去控制
	**深拷贝**:把 被复制指针 指向的值 复制到 要复制的指针 指向的地址中

具体表现为使用new创建了一块内存给某个变量,但后面使用浅拷贝把指针指向别处,导致这块内存不能被访问,也不能被删除
```cpp
	int *a = new int (8);
	
	int *b = a;    //浅拷贝 即只复制指针,new里的内存泄露 危险❌
	
	int *b;
	*b = *a;    //深拷贝 把值赋值到new的内存中 安全✅
```
内存泄露之后,常常容易造成double free重复释放,即一块地址中的内容被free()函数释放两次,在第一次free时,指针和内容都被删除,第二次free时,只剩指针,此时的指针被成为**悬空指针**,报错

当数据成员中有指针时，必须要在拷贝构造函数中使用深拷贝

解决内存泄漏的方法：
---
1. 使用RAII（Resource Acquisition Is Initialization）原则，将资源封装在类中，利用析构函数自动释放资源。
    
2. 使用智能指针（如std::unique_ptr, std::shared_ptr）来管理动态分配的内存，它们会在适当的时候自动释放内存。
    
3. 确保每个new都有对应的delete，在代码中注意匹配。在构造函数中分配资源，在析构函数中释放。
    
4. 避免在函数中提前返回或抛出异常时忘记释放内存，可以使用RAII或智能指针来避免。
    
5. 使用容器（如std::vector, std::string）来代替原生的数组和字符串，它们会自动管理内存。
    
6. 使用内存检测工具（如Valgrind, AddressSanitizer）来检测内存泄漏。

解决double free的方法：
---
1. 使用RAII和智能指针，因为智能指针会自动管理内存，避免重复释放。
    
2. 在释放内存后，将指针设置为nullptr，这样再次释放nullptr是安全的（delete nullptr是空操作）。
    
3. 实现拷贝控制成员（拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符）时，遵循Rule of Three/Five，确保深拷贝或正确转移资源所有权。
    
4. 避免多个指针指向同一块内存，如果必须共享，使用std::shared_ptr，它使用引用计数来管理内存。
    
5. 在移动操作后，将源对象的指针置为nullptr，确保移动后的对象不再拥有资源，从而不会在析构时释放资源。
    
6. 注意对象的生命周期，避免在栈上返回局部变量的地址或引用。
    
7. 使用容器和标准库管理资源，避免手动管理。



