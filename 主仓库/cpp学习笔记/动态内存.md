C++ 程序中的内存分为两个部分：

- **栈：** 在函数内部声明的所有变量都将占用栈内存。
- **堆：** 这是程序中未使用的内存，在程序运行时可用于动态分配内存。

您可以使用***new*** 运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。
如果您不再需要动态分配的内存空间，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。

## 数组的动态内存分配 ##

创建:
```cpp
char* pvalue  = NULL;   // 初始化为 null 的指针
pvalue  = new char[20]; // 为变量请求内存
```
删除
```cpp
delete [] pvalue;        // 删除 pvalue 所指向的数组
```

## 多维数组

注意数组存的是int 还是指针(int \*),或是指向指针的指针(int \*\*)

<font color = yellow >  delete 与 delete[] 区别：</font>
1. 针对简单类型 使用 new 分配后的不管是数组还是非数组形式内存空间用两种方式均可 如：
	```cpp
	int *a = new int[10];   
	delete a;   
	delete [] a;
	```
	此种情况中的释放效果相同，原因在于：分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数， 它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间
2. 针对类Class，两种方式体现出具体差异
	```cpp
	class A
	{
	    private:
	        char *m_cBuffer;
	        int m_nLen;
	    public:
	        A(){ m_cBuffer = new char[m_nLen]; }
	        ~A() { delete [] m_cBuffer; }
	};
	A *a = new A[10];
	
	// 仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏
	delete a;
	
	// 调用使用类对象的析构函数释放用户自己分配内存空间并且   释放了a指针指向的全部内存空间
	delete [] a;
	```

- **delete ptr** -- 代表用来释放内存，且只用来释放ptr指向的内存。
-  **delete[] rg** -- 用来释放rg指向的内存，！！还逐一调用数组中每个对象的 destructor！！




一维
```cpp
// 动态分配,数组长度为 m
int *array=new int [m];
 
//释放内存
delete [] array;
```

二维
```cpp
int **array;
// 假定数组第一维长度为 m， 第二维长度为 n
// 动态分配空间
array = new int *[m]; //注意!!!
for( int i=0; i<m; i++ )
{
    array[i] = new int [n];
}
//释放
for( int i=0; i<m; i++ )
{
    delete [] array[i];
}
delete [] array;
```

三维
```cpp
int ***array;
// 假定数组第一维为 m， 第二维为 n， 第三维为h
// 动态分配空间
array = new int **[m];
for( int i=0; i<m; i++ )
{
    array[i] = new int *[n];
    for( int j=0; j<n; j++ )
    {
        array[i][j] = new int [h];
    }
}
//释放
for( int i=0; i<m; i++ )
{
    for( int j=0; j<n; j++ )
    {
        delete[] array[i][j];
    }
    delete[] array[i];
}
delete[] array;
```

## 对象的动态内存分配

new调用构造函数,delete调用析构函数
