
| 特性   | 虚函数（Virtual Function）  | 纯虚函数（Pure Virtual Function） |
| ---- | ---------------------- | --------------------------- |
| 定义   | 基类中使用 `virtual` 声明，有实现 | 基类中使用 `= 0` 声明，无实现          |
| 子类重写 | 子类可以选择重写               | 子类必须实现                      |
| 抽象性  | 可以实例化类                 | 使类变为抽象类，无法实例化               |
| 用途   | 提供默认行为，允许子类重写          | 定义接口，强制子类实现具体行为             |
多态
---
- **虚函数**：通过在基类中使用 `virtual` 关键字声明虚函数，派生类可以重写这个函数，从而使得在运行时根据对象类型调用正确的函数。
    
- **动态绑定**：C++ 的多态通过动态绑定实现。在运行时，基类指针 `animalPtr` 会根据它实际指向的对象类型（`Dog` 或 `Cat`）调用对应的 `sound()` 方法。
    
- **虚析构函数**：在具有多态行为的基类中，析构函数应该声明为 `virtual`，以确保在删除派生类对象时调用派生类的析构函数，防止资源泄漏。

虚函数
---
- **在基类中可以有实现**。通常虚函数在基类中提供默认实现，但子类可以选择重写。
- **动态绑定**：在运行时根据对象的实际类型调用相应的函数版本。
- **可选重写**：派生类可以选择性地重写虚函数，但不是必须。


纯虚函数
 ---
纯虚函数是没有实现的虚函数，在基类中用 = 0 来声明。

纯虚函数表示基类定义了一个接口，但具体实现由派生类负责。

纯虚函数使得基类变为抽象类（abstract class），无法实例化。

**特点：**
- **必须在基类中声明为 `= 0`**，表示没有实现，子类必须重写。
- **抽象类**：包含纯虚函数的类不能直接实例化，必须通过派生类实现所有纯虚函数才能创建对象。
- **接口定义**：纯虚函数通常用于定义接口，让派生类实现具体行为。

**动态联编的实现机制 VTABLE**
---

编译器对每个包含虚函数的类创建一个虚函数表VTABLE，表中每一项指向一个虚函数的地址，即VTABLE表可以看成一个函数指针的数组，每个虚函数的入口地址就是这个数组的一个元素。

每个含有虚函数的类都有各自的一张虚函数表VTABLE。每个派生类的VTABLE继承了它各个基类的VTABLE，如果基类VTABLE中包含某一项（虚函数的入口地址），则其派生类的VTABLE中也将包含同样的一项，但是两项的值可能不同。如果派生类中重载了该项对应的虚函数，则派生类VTABLE的该项指向重载后的虚函数，如果派生类中没有对该项对应的虚函数进行重新定义，则使用基类的这个虚函数地址。

在创建含有虚函数的类的对象的时候，编译器会在每个对象的内存布局中增加一个vptr指针项，该指针指向本类的VTABLE。在通过指向基类对象的指针（设为bp）调用一个虚函数时，编译器生成的代码是先获取所指对象的vtb1指针，然后调用vtb1所指向类的VTABLE中的对应项（具体虚函数的入口地址）。

当基类中**没有定义虚函数**时，其长度=数据成员长度；派生类长度=自身数据成员长度+基类继承的数据成员长度；

当基类中**定义虚函数后**，其长度=数据成员长度+虚函数表的地址长度；派生类长度=自身数据成员长度+基类继承的数据成员长度+虚函数表的地址长度。

包含一个虚函数和几个虚函数的类的长度增量为0。含有虚函数的类只是增加了一个指针用于存储虚函数表的首地址。

派生类与基类同名的虚函数在VTABLE中有相同的索引号（或序号）。

虚函数可以不实现（定义）。不实现（定义）的虚函数是纯虚函数。

在一个类中如果存在未定义的虚函数，那么不能直接使用该类的实例，可以理解因为未定义 virtual 函数，其类是抽象的，无法实例化。

```cpp
using namespace std;

class Base {
public:
    virtual void tall();
};

class People : Base {
public:
    void tall() {
        cout << "people" << endl;
    };
};
int main() {
//    Base base;//不可用 因为base.tall未定义
    People people;//可用 因为people.tall已重载
    people.tall();
    (&people)->tall();

    return 0;
}
```

那么，在 main 方法中，我们不能使用 Base base; 这行代码，此时的 tall 没有实现，函数表（vtable）的引用是未定义的，故而无法执行。但我们可以使用 People people; 然后 people.tall(); 或 (&people)->tall(); 因为People实现或者说重写、覆盖了 Base 的纯虚方法 tall()，使其在 People 类中有了定义，函数表挂上去了，于是可以诞生实例了。

## 使用final关键字可以避免函数被再次重写,或class被继承
```cpp
class Base
{
    public:
        virtual void func()
        {
            cout<<"This is Base"<<endl;
        }
};
class _Base:public Base
{
    public:
        void func() final//正确，func在Base中是虚函数
        {
            cout<<"This is _Base"<<endl;
        }
};
class __Base:public _Base
{
/*    public://不正确，func在_Base中已经不再是虚函数，不能再被重写
        void func()
        {
            cout<<"This is __Base"<<endl;
        }*/
};
```
```cpp
class Base final{}
class Derived : Base{} // 错误 不能继承了
```